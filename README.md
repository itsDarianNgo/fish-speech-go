# fish-speech-go

This repository provides Go utilities for streaming audio generated by a Fish-Speech backend.

## Chunk streaming concurrency control

The chunker uses a semaphore to cap concurrent streaming tasks. You **must** provide the
maximum number of concurrent streams and (optionally) a timeout for acquiring a slot.

```go
chunker, err := streaming.NewChunker(streaming.Options{
    MaxConcurrent: 4,                    // required
    AcquireTimeout: 2 * time.Second,     // optional; 0 relies on the caller's context
})
if err != nil {
    log.Fatal(err)
}
```

Use the `Stream` helper (or call `Acquire` directly) to guard any operation that pushes
chunks to a client. The call will return a `ChunkerError` when the semaphore cannot be
acquired, allowing your handler to respond gracefully instead of blocking indefinitely.

```go
err = chunker.Stream(r.Context(), func(ctx context.Context) error {
    // produce and send chunks here
    return nil
})
if errors.Is(err, streaming.ErrLimitExceeded) {
    // respond with 503 or enqueue the request instead of overwhelming the backend
}
if errors.Is(err, streaming.ErrAcquireTimeout) {
    // inform the caller that the stream could not be scheduled quickly enough
}
```

### Behavior

- `MaxConcurrent` is required and must be greater than zero.
- `AcquireTimeout` limits how long the chunker waits for a permit. When the timeout is
  exceeded, the call returns `ErrAcquireTimeout` and no work is performed.
- When the caller cancels the context while waiting for a slot, the chunker returns
  `ErrLimitExceeded` to signal that the request was dropped instead of queued indefinitely.

These controls make streaming predictable under load: rather than letting clients pile up
behind a busy backend, the server can enforce an upper bound on active streams and react to
scheduling pressure with structured errors.

